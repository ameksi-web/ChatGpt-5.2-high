<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Море</title>

  <!-- убирает 404 на favicon.ico -->
  <link rel="icon" href="data:,">

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background:#000; }
    canvas { display:block; }
  </style>

  <!-- ВАЖНО: importmap должен быть ДО <script type="module"> -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { Water } from "three/addons/objects/Water.js";
  import { Sky } from "three/addons/objects/Sky.js";

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.05;
  renderer.physicallyCorrectLights = true;
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0b1520, 0.00008);

  const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 20000);
  camera.position.set(0, 55, 180);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.maxPolarAngle = Math.PI * 0.49;
  controls.minDistance = 30;
  controls.maxDistance = 900;

  // Sky
  const sky = new Sky();
  sky.scale.setScalar(10000);
  scene.add(sky);

  const skyU = sky.material.uniforms;
  skyU.turbidity.value = 8.0;
  skyU.rayleigh.value = 2.2;
  skyU.mieCoefficient.value = 0.006;
  skyU.mieDirectionalG.value = 0.82;

  const sun = new THREE.Vector3();
  const pmrem = new THREE.PMREMGenerator(renderer);
  let envRT = null;

  const sunLight = new THREE.DirectionalLight(0xffffff, 4.2);
  scene.add(sunLight);
  scene.add(sunLight.target);

  const hemi = new THREE.HemisphereLight(0xbfe9ff, 0x061018, 0.35);
  scene.add(hemi);

  function updateSun(elev = 10, azim = 175) {
    const phi = THREE.MathUtils.degToRad(90 - elev);
    const theta = THREE.MathUtils.degToRad(azim);
    sun.setFromSphericalCoords(1, phi, theta);

    skyU.sunPosition.value.copy(sun);

    if (envRT) envRT.dispose();
    envRT = pmrem.fromScene(sky);
    scene.environment = envRT.texture;

    sunLight.position.copy(sun).multiplyScalar(2000);
    sunLight.target.position.set(0, 0, 0);
    sunLight.target.updateMatrixWorld();
  }

  // Water normals (лучше хранить локально, но пока можно так)
  const texLoader = new THREE.TextureLoader();
  texLoader.setCrossOrigin("anonymous");

  const waterNormals = texLoader.load(
    "https://threejs.org/examples/textures/waternormals.jpg",
    (t) => {
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(12, 12);
    }
  );

  const waterGeo = new THREE.PlaneGeometry(12000, 12000);
  const water = new Water(waterGeo, {
    textureWidth: 1024,
    textureHeight: 1024,
    waterNormals,
    sunDirection: new THREE.Vector3(1, 1, 1),
    sunColor: 0xffffff,
    waterColor: 0x0a3b55,
    distortionScale: 4.2,
    fog: true
  });
  water.rotation.x = -Math.PI / 2;
  scene.add(water);

  updateSun(10, 175);

  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    water.material.uniforms.time.value += clock.getDelta() * 0.8;
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  });
</script>
</body>
</html>
